package knapsack;

import java.util.*;

public class Knapsack {
    List<Item> items;
    int n;
    int capacity;
    int[][] dp;

    public Knapsack(List<Item> items, int capacity) {
        this.items = items;
        this.capacity = capacity;
        this.n = items.size();
        dp = new int[n + 1][capacity + 1];
    }

    int MaxProfitUsingQueue() {
        this.items.sort(new Compare());
        int maxProfit = 0;
        Node node1 = new Node();
        Node node2 = new Node();

        //dummy node
        node1.level = -1;
        node1.profit = 0;
        node1.weight = 0;
        Queue<Node> q = new LinkedList<>();
        q.add(node1);
        while (!q.isEmpty()) {
            node1 = q.poll();
            if (node1.level == n - 1)
                continue;
            node2.level = node1.level + 1;
            node2.profit = node1.profit + items.get(node2.level).profit;
            node2.weight = node1.weight + items.get(node2.level).weight;
            maxProfit = node2.weight <= capacity && node2.profit > maxProfit ? node2.profit : maxProfit;
            BoundClass boundClass = new BoundClass(node2, items, capacity);
            node2.bound = boundClass.bound();
            //System.out.println("x=1 " + node2.bound + " " + node2.profit + " " + node2.weight + " " + node2.level);

            if (node2.bound > maxProfit)
                q.add(node2);
            Node node3 = new Node();
            node3.level = node2.level;
            node3.weight = node1.weight;
            node3.profit = node1.profit;
            node3.bound = node2.bound;
            boundClass = new BoundClass(node3, items, capacity);
            node3.bound = boundClass.bound();
            if (node3.bound > maxProfit)
                q.add(node3);
            //System.out.println("x=0 " + node3.bound + " " + node3.profit + " " + node3.weight + " " + node3.level);
        }
        return maxProfit;
    }

    public int Memoization(int n, int capacity) {
        if (n == 0 || capacity == 0) //no profit in case of no item or 0 capacity
            return 0;
        if (dp[n][capacity] != -1)
            return dp[n][capacity];
        if (items.get(n - 1).weight > capacity) //if current item weight is more than the capacity, then leave it
            return dp[n][capacity] = Memoization(n - 1, capacity);
        return dp[n][capacity] = Math.max(items.get(n - 1).profit +
                Memoization(n - 1, (int) (capacity - items.get(n - 1).weight)), Memoization(n - 1, capacity));
        // else take max profit generated by taking item or not taking item
    }

    public int MaxProfitUsingStack() {
        for (int i = 0; i <= n; i++) {
            for (int j = 0; j <= capacity; j++)
                dp[i][j] = -1;
        }
        // this is a recursive also so will use recursion stack
        return Memoization(n, capacity);
    }
}
